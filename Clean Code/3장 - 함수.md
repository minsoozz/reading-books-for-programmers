# 주석

> 어떤 프로그램이든 가장 기본적인 단위가 함수다. 이 장은 함수를 잘 만드는 법을 소개한다.

## 작게 만들어라

함수를 만드는 규칙은 '작게' 이다. 이 규칙은 근거를 대기가 곤란하다. 함수가 작을수록 더 좋다는 증거나 자료를 제시하기도 어렵지만,오랜 시행착오를 바탕으로 작은 함수가 좋다고 확신한다.

### 블록과 들여쓰기

if문 / else 문 / while 문 등에 들어가는 블록은 한 줄이어야 한다는 의미다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도
쉬워진다. 함수에서 들여쓰기 기준은 1단이나 2단을 넘어서면 안 된다. 그래야 함수는 읽고 이해하기 쉬워진다.

## 한 가지만 해라

> 함수는 한 가지를 해야 한다. 그 한가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

## 함수 당 추상화 수준은 하나로

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 한 함수내 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기
어려운 탓이다.

### 위에서 아래로 코드 읽기: 내려가기 규칙

코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위애서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. 이것을 내려가기
규칙이라 부른다. 하지만 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다. 많은 프로그래머가 곤란을 겪는다. 그렇지만 매우 중요한 규칙이다. 핵심은 짧으면서도 '한가지' 만 하는 함수다.

## Switch 문

switch 문은 작게 만들기 어렵다. case 분기가 단 두개인 switch 문도 내 취향에는 너무 길며, 단일 블록이나 함수를 선언한다. 또한 '한가지' 작업만 하는 switch 문도 만들기 어렵다. 본질적으로
switch 문은 N가지를 처리한다. 불행하게도 switch 문을 완전히 피할 방법은 없다. 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성을 이용한다. 아래의
코드를 살펴보자. 직원 유형에 따라 다른 값을 계산해 반환하는 함수다.

```
public Money calculatePay(Employee e)
throws InvalidEmploiyeeType {
    switch (e.type) {
        case COMMISSIONED:
            return calculcateCommissionedPay(e);
        case HOURLY:
            return calculcateHourlyPay(e);
        case SALARIED:
            return calculcateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

위 함수에는 몇 가지 문제가 있다.

1. 함수가 길다. (새 직원 유형을 추가하면 더 길어진다.)
2. '한 가지' 작업만 수행하지 않는다.
3. SRP (Single Responsibility Principle) 를 위반한다. (코드를 변경할 이유가 여럿이기 때문이다.)
4. OCP (Open Closed Principle) 를 위반한다. (새 직원 유행을 추가할 때마다 코드를 변경하기 때문이다.)

하지만 아마 가장 심각한 문제라면 위 함수와 구조가 동일한 함수가 무한정 존재한다는 사실이다. 예를 들어, 다음과 같은 함수가 가능하다.

```
isPayday(Employee e, Date date);
deliverPay(Employee e, Date date);
```

가능성은 무한하다. 그리고 모두가 똑같이 유해한 구조다.