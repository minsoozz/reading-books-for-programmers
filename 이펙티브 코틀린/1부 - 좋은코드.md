# 아이템 1 - 가변성을 제한하라

## 가변성의 단점

1. 프로그램을 이해하고 디버깅이 어려워진다.
2. 가변성이 있으면 코드의 실행을 추론하기 어렵다.
3. 멀티스레드 프로그래밍에서는 동기화가 필요하다.
4. 테스트하기 어렵다.
5. 상태 변경이 일어난다면, 변경을 다른 부분에 알려야하는 경우가 있다.

## 코틀린에서 가변성 제한하기

### 가변성을 제한하는 방법

1. 읽기 전용 프로퍼티(val)
2. 가변 컬렉션과 읽기 전용 컬렉션 구분하기
3. 데이터 클래스의 copy

### 불변 객체의 장점

1. 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
2. 객체를 공유했을 때 충돌이 따로 이루어지지 않아 병렬처리를 안전하게 할 수 있다.
3. 참조가 변경되지 않아 쉽게 캐시할 수 있다.
4. 방어적 복사를 할 필요가 없다.
5. `set` 또는 `map` 의 key로 사용할 수 있다.

# 아이템 2 - 변수의 스코프를 최소화하라

변수는 최대한 스코프를 좁게 설정하는 것이 좋다. 변수의 스코프 범위가 너무 넓으면, 다른 개발자에 의해서 변수가 잘못 사용될 수 있다. 
여러 프로퍼티를 한꺼번에 설정해야 하는 경우에는 구조분해 선언을 활용하는 것이 좋다.

# 아이템 3 - 최대한 플랫폼 타입을 사용하지 말라

코틀린은 자바 등의 다른 프로그래밍 언어에서 넘어온 타입들을 특수하게 다룬다. 이러한 타입을 플랫폼 타입이라고 부른다.

자바를 코틀린과 함께 사용할 때, 자바 코드를 직접 조작할 수 있다면, 가능한 `@Nullable`, `@NotNull` 어노테이션을 사용하자.

# 아이템 4 - inferred 타입으로 리턴하지 말라

타입을 확실하게 지정해야 하는 경우에는 명시적으로 타입을 지정해야한다는 원칙만 갖자. inferred 타입은 제한이 너무 많아지거나 예측하지 못한 결과를 낼 수 있다.

# 아이템 5 - 예외를 활용해 코드에 제한을 걸어라

코틀린에서는 코드의 동작에 제한을 걸 때 다음과 같은 방법을 사용할 수 있다.

1. require: 아규먼트를 제한할 수 있다.
2. check: 상태와 관련된 동작을 제한할 수 있다.
3. assert: 어떤 것이 true 인지 확인할 수 있다. (테스트 모드에서만 동작)
4. elvis 연산자

# 아이템 6 - 사용자 정의 오류보다는 표준 오류를 사용하라

표준 라이브러리 오류로 표현할 수 있다면 최대한 사용하는 것이 좋다~

# 아이템 7 - 결과 부족이 발생할 경우 null과 Failure를 사용하라

예상되는 예외는 null, Failure로 표현하고 예측하기 어려운 예외는 throw 하자~

하지만 일반적으로 `getOrNull` 또는 `Elvis` 연산자를 사용하는 것이 쉽다. nullable을 리턴하지 말고 무엇이 리턴되는지 예측할 수 있게 하는 것이 좋다.

# 아이템 8 - 적절하게 null을 처리하라

not-null assertion(!!)로 코드를 작성하면, 이후에 프로퍼티를 계속해서 언팩해야 하므로 사용하기 귀찮다. 이러한 코드를 작성하는 올바른 방법은 lateinit 또는 Delegates.notNull을 사용하는 것이다.

# 아이템 9 - use를 사용하여 리소스를 닫아라

use를 사용하면 Closeable/AutoCloseable을 구현한 객체를 쉽고 안전하게 처리할 수 있다~

# 아이템 10 - 단위 테스트를 만들어라

테스트는 중요하다.

